#!/usr/bin/env python

import pymc as pm
from pymc.Matplot import plot
import sys
import os
import simplejson as json
import argparse
import itertools

parser = argparse.ArgumentParser(description="Analyze Billiards games and " +
                                "output some statistics.")
parser.add_argument("matches", help="A JSON file containing match data",
                    type=argparse.FileType('r'))
parser.add_argument('-p', "--plot", dest='plot', action='store_true', 
                    help="Plot the statistics for each player at the end")


# Setup the system path for easily executing the script in development
path = os.path.abspath(sys.argv[0])
while os.path.dirname(path) != path:
    if os.path.exists(os.path.join(path, 'analyzer', '__init__.py')):
        sys.path.insert(0, path)
        break
    path = os.path.dirname(path)

from analyzer import analyze

def players_from_match(match):
    if "players" in match:
        return match['players']
    else:
        return match['winners'] + match['losers']

def json_to_matches(matches_json):
    players_for_each_match = map(players_from_match, matches_json)
    all_player_names = set(itertools.chain(*players_for_each_match))
    player_lookup = {}
    for name in all_player_names:
        player_lookup[name] = analyze.new_player(name)
        
    matches = []
    for match in matches_json:
        if "players" in match:
            pass
            players = map(lambda p: player_lookup[p], match['players'])
            winning_team = match['winning-team']
            newMatch = analyze.Match(players, winning_team, "partial")
        else:
            winners = map(lambda p: player_lookup[p], match['winners'])
            losers = map(lambda p: player_lookup[p], match['losers'])
            ordered = "unordered"
            if "ordered" in match:
                ordered = "partial"

            if "foul-end" in match:
                foul_end = match['foul-end']
            else:
                foul_end = False
            
            players = analyze.zip_lists(winners, losers)
            newMatch = analyze.Match(players, 0, ordered, foul_end)
        matches.append(newMatch)

    return matches

def find_all_players(matches):
    return set(itertools.chain(*map(players_from_match, matches)))

args = parser.parse_args()

matches_json = json.loads(args.matches.read())
matches = json_to_matches(matches_json)

all_match_vars = analyze.all_matches(matches)
match_outcomes = analyze.outcomes(all_match_vars)

def player_nodes(player):
    return player.values()

def match_player_nodes(match):
    return itertools.chain(*map(lambda p: player_nodes(p), match.players))

def player_nodes_from_matches(matches):
    return itertools.chain(*map(lambda m: match_player_nodes(m), matches))

players = list(set(player_nodes_from_matches(matches)))
all_nodes = players + all_match_vars + match_outcomes

model = pm.MCMC(all_nodes)
model.sample(iter=2000, burn=0, thin=1)
print "" # Advance one line to avoid overlap when outputting the data below

# Collect stats, sort the players by their mean sink ranking and print 
# the results
stats = model.stats()
player_vars = filter(lambda n: isinstance(n, pm.Variable), players)
sorted_players = sorted(player_vars, key=lambda p: stats[p.__name__]['mean'])
for player in sorted_players:
    print player.__name__  + ": " + str(stats[player.__name__]['mean'])

if args.plot:
    plot(model)

def player_from_stats(stats, player):
    new_player = {}
    for attr in player:
        if isinstance(player[attr], pm.Variable):
            new_player[attr] = stats[player[attr].__name__]['mean']
    return new_player

correct = 0
for match in matches:
    players = map(lambda p: player_from_stats(stats, p), match.players)

    if match.order == "unordered":
        eval_method = analyze.match_eval_markov_unordered
    else:
        eval_method = analyze.match_eval_markov_partial_ordered

    chance_of_win = eval_method(players, match.winning_team, match.foul_end)
    if chance_of_win > 0.5:
        correct += 1

print "Correctly guessed %(correct)d out of %(total)d matches" % \
      {"correct": correct, "total": len(matches) }
