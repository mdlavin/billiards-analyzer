#!/usr/bin/env python

import pymc as pm
from pymc.Matplot import plot
import sys
import os
import simplejson as json
import argparse
import itertools

parser = argparse.ArgumentParser(description="Analyze Billiards games and " +
                                "output some statistics.")
parser.add_argument("matches", help="A JSON file containing match data",
                    type=argparse.FileType('r'))
parser.add_argument('-p', "--plot", dest='plot', action='store_true', 
                    help="Plot the statistics for each player at the end")


# Setup the system path for easily executing the script in development
path = os.path.abspath(sys.argv[0])
while os.path.dirname(path) != path:
    if os.path.exists(os.path.join(path, 'analyzer', '__init__.py')):
        sys.path.insert(0, path)
        break
    path = os.path.dirname(path)

from analyzer import analyze

def new_player(name): 
    return pm.Beta(name + "_sink", alpha=3, beta=3, value=0.5)

def players_from_match(match):
    if "players" in match:
        return match['players']
    else:
        return match['winners'] + match['losers']

def json_to_matches(matches_json):
    players_for_each_match = map(players_from_match, matches_json)
    all_player_names = set(itertools.chain(*players_for_each_match))
    player_var_lookup = {}
    for name in all_player_names:
        player_var_lookup[name] = new_player(name)
        
    matches = []
    for match in matches_json:
        if "players" in match:
            pass
            player_vars = map(lambda p: player_var_lookup[p], match['players'])
            winning_team = match['winning-team']
            newMatch = analyze.Match(player_vars, winning_team, "partial")
        else:
            winner_vars = map(lambda p: player_var_lookup[p], match['winners'])
            losers_vars = map(lambda p: player_var_lookup[p], match['losers'])
            ordered = "unordered"
            if "ordered" in match:
                ordered = "partial"
            
            players = analyze.zip_lists(winner_vars, losers_vars)
            newMatch = analyze.Match(players, 0, ordered)
        matches.append(newMatch)

    return matches

def find_all_players(matches):
    return set(itertools.chain(*map(players_from_match, matches)))

args = parser.parse_args()

matches_json = json.loads(args.matches.read())
matches = json_to_matches(matches_json)

all_match_vars = analyze.all_matches(matches)
match_outcomes = analyze.outcomes(all_match_vars)

players = list(set(itertools.chain(*map(lambda m: m.players, matches))))
all_vars = players + all_match_vars + match_outcomes

model = pm.MCMC(all_vars)
model.sample(iter=2000, burn=0, thin=1)
print "" # Advance one line to avoid overlap when outputting the data below

# Collect stats, sort the players by their mean sink ranking and print 
# the results
stats = model.stats()
sorted_players = sorted(players, key=lambda p: stats[p.__name__]['mean'])
for player in sorted_players:
    print player.__name__  + ": " + str(stats[player.__name__]['mean'])

if args.plot:
    plot(model)

correct = 0
for match in matches:
    players = map(lambda p: stats[p.__name__]['mean'], match.players)

    if match.order == "unordered":
        eval_method = analyze.match_eval_markov_unordered
    else:
        eval_method = analyze.match_eval_markov_partial_ordered

    chance_of_win = eval_method(players, match.winning_team)
    if chance_of_win > 0.5:
        correct += 1

print "Correctly guessed %(correct)d out of %(total)d matches" % \
      {"correct": correct, "total": len(matches) }
